{
module SceneLexer(Token(..), tokenize) where

import Data.Maybe
import Text.Read
}

%wrapper "monadUserState"

$sign  = [\+\-]
$digit = [0-9]
$alpha = [a-zA-Z]
$idSym = [a-zA-Z0-9\_\']
$noNewLine = ~ \n

tokens :-
    $white+                         ;
    \# .*                           ;
    vertex                          { fromMatch (const TokenVertex) }
    vertices                        { fromMatch (const TokenVertices) }
    colors                          { fromMatch (const TokenColors) }
    materials                       { fromMatch (const TokenMaterials) }
    shapes                          { fromMatch (const TokenShapes) }
    poly                            { fromMatch (const TokenPoly) }
    sphere                          { fromMatch (const TokenSphere) }
    light                           { fromMatch (const TokenLight) }
    camera                          { fromMatch (const TokenCamera) }
    $sign? $digit+                  { fromMatch (TokenInt . read) }
    $sign? $digit+ \. $digit+       { fromMatch (TokenFloat . read) }
    $alpha $idSym*                  { fromMatch TokenId }

{

data Token
    = TokenVertex
    | TokenVertices
    | TokenColors
    | TokenMaterials
    | TokenShapes
    | TokenPoly
    | TokenSphere
    | TokenLight
    | TokenCamera
    | TokenInt Int
    | TokenFloat Double
    | TokenId String
    | TokenEOF
    deriving (Show, Eq)

fromMatch :: (String -> Token) -> AlexInput -> Int -> Alex Token
fromMatch f input len = pure (f (take len s))
  where
    (_, _, _, s) = input

data AlexUserState = AlexUserState Int

alexInitUserState :: AlexUserState
alexInitUserState = AlexUserState 0

alexEOF :: Alex Token
alexEOF = pure TokenEOF

tokens :: Alex [Token]
tokens = do
    t <- alexMonadScan
    if t == TokenEOF
        then pure [TokenEOF]
        else (t :) <$> tokens

tokenize :: String -> Either String [Token]
tokenize = flip runAlex tokens

lexer :: Monad m => String -> (Token -> m a) -> Either String (m a)
lexer text f = runAlex text $ do
    f <$> alexMonadScan

-- This is required to suppress warning generated by stupid Alex.
useAp :: Monad m => m (a -> b) -> m a -> m b
useAp = Control.Monad.ap

}
